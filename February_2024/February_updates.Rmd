---
title: \sf February_updates
header-includes:
- \usepackage{color}
- \usepackage{float}
- \DeclareUnicodeCharacter{2212}{-}
date: "February 05, 2024"
output:
  bookdown::html_document2:
    toc: true
fontsize: 14pt
geometry: margin=1in
---

```{css, echo=FALSE}
body .main-container {
  max-width: 1200px !important;
  width: 1200px !important;
}
body {
  max-width: 1200px !important;
}

pre {
  max-height: 600px;
  overflow-y: auto;
}

pre[class] {
  max-height: 600px;
}
```

```{css, echo=FALSE}
.watch-out {
  background-color: lightcyan;
  border: 3px solid lightgrey;
  font-weight: bold;
}

.revision {
  background-color: #FFF4F2;
  border: 3px solid lightgrey;
  font-weight: bold;
}

.highlighted
{
   color:red;
}

.highlighted2
{
   color:blue;
}
```

```{r engine='R', eval=TRUE, echo=F}
knitr::opts_chunk$set(class.source = "watch-out")
```


# Install required packages
Install `bigWig` and `latticeExtra` package \
```{r engine='R', eval=F, echo=T}
install.packages("devtools", quiet = TRUE)
library(devtools)
devtools::install_github('andrelmartins/bigWig',
              subdir='bigWig')
library(bigWig)

install.packages("DESeq2", quiet = TRUE)
install.packages("dplyr", quiet = TRUE)
```

Install `bedtools` \
```{r engine='bash', eval=F, echo=T}
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
brew install bedtools
```

Install `Biostrings` \
```{r engine='R', eval=TRUE, echo=T}
if (!requireNamespace("Biostrings", quietly = TRUE)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install("Biostrings")
}
```

Install `latticeExtra` \
```{r engine='R', eval=TRUE, echo=T}
install.packages("latticeExtra", quiet = TRUE)
```

# Feb 5th

# RSAT - DYAD analysis

In the previous analysis, I ran the RSAT-dyad analysis, using the ENCODE DHS regions as a control for calculating the expected 3mer dyad occurrence, and generated these files with dyad patterns and the corresponding statistics. \
Command that I used: \

```{r engine='bash', eval=F, echo=TRUE}
rsat dyad-analysis -o GATA3_peak_161win_with_motif_1_RSAT_dyad.txt -i GATA3_peak_161win_with_motif_1.fasta -format FastA -l 3 -sp 0-20 -expfreq ENCODE.MCF7.DHS.background4.txt -return exp_occ,occ,ratio -sort -seqtype dna 


# -1str	single strand count; only the direct strand is considered for oligonucleotide and dyad occurrence counting.
# -2str	count on oth strands
		#The occurrences of each oligonucleotide are summed on both strands. This allows to detect elements which act in an orientation-insensitive way (as is generally the case for yeast upstream elements).
		
# -type dyad_type (dr|ir|any) any	(default)
		#In order to fasten execution, the program can be asked to restrict its analysis to symmetric dyads.
		#Three types are accepted
		   #dr	direct repeats: the second element is the same as the first one
		   #ir	inverted repeats: the second element is the reverse complement of the first one.
		   #rep  repeats: direct and inverted repeats are evaluated
		   #any	(default)
			 #When selecting the option any, the analysis is performed on all non-symmetric dyads as well.
```

Refer to the help menu. \
```{r engine='bash', eval=F, echo=TRUE}
cd /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP_final/GAT_3mer_analaysis/RSAT/
source ~/miniconda3/bin/activate
conda activate rsat
#rsat --help
rsat oligo-analysis -h
rsat create-background-model -h
rsat dyad-analysis -h
```


Files generated: \
GATA3_peak_161win_with_motif_1_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_2_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_4_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_5_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_6_RSAT_dyad.txt \

```{r engine='bash', eval=F, echo=TRUE}
head -6 GATA3_peak_161win_with_motif_1_RSAT_dyad.txt
#sequence  	identifier             	expected_freq	occ	exp_occ	ovl_occall_occ	ratio
#gatn{3}atc	gatn{3}atc|gatn{3}atc	0.0000716460535	  12482	  85.98	36	12518	 145.17
#agan{4}atc	agan{4}atc|gatn{4}tct	0.0003298219842	  10904	 390.07	4445	15349	  27.95
#atan{2}atc	atan{2}atc|gatn{2}tat	0.0001616794646	  10453	 196.05	1460	11913	  53.32
#gatn{4}tca	gatn{4}tca|tgan{4}atc	0.0003742452755	   7872	 442.61	1728	9600	  17.79
#agan{3}tat	agan{3}tat|atan{3}tct	0.0002979478048	   7425	 357.56	613	8038	  20.77

```

The first column is the sequence pattern RSAT-dyad analysis found. **Notice that the n{x} is the spacing between the elements of the dyad. The spacing is the number of bases between the end of the first element and the start of the second one.. This is different with the way we refer to as "relative distance" anchor at the G of two 3mer.** We will modify this while processing the data. \

The second column is all identifier for that specific pattern. Notice that while running the dyad analysis, we specified the parameter `-1str` to only count the direct strand. Thus, only the main structure and its reverse compliment (for both 3mer) is unquely listed in the result files. This is convenient for downstream analysis. \

The final column represents the ratio of observed occurrences to expected occurrences (occ/exp_occ), which can serve as a rough "enrichment score". I plan to extract patterns linked to GAT/ATC and create a bar chart or xyplot to visually depict their frequencies. \
**Notice that using this ratio may overestimate some patterns** \

```{r engine='bash', eval=F, echo=TRUE}
awk -F'\t' '$1 ~ /^gat.*atc/' GATA3_peak_161win_with_motif_1_RSAT_dyad.txt | wc -l
#21

awk -F'\t' '$1 ~ /^atc.*gat/' GATA3_peak_161win_with_motif_1_RSAT_dyad.txt  | wc -l
#21
```



**In RSAT-dyad analysis, gat-atc and atc-gat means two different structure**. \
```{r engine='bash', eval=TRUE, echo=TRUE}
awk -F'\t' '$1 ~ /^gat.*atc/' GATA3_peak_161win_with_motif_1_RSAT_dyad.txt | sort -k8,8nr
echo " "
awk -F'\t' '$1 ~ /^atc.*gat/' GATA3_peak_161win_with_motif_1_RSAT_dyad.txt | sort -k8,8nr
```

**Notice that:** \
1) the x value of n{x} (spacings) in RSAT is defined differently than in the customized analysis. For instance, gatn{3}atc has what we define in customized analysis as a 8bp relative distance between the G in gat and C in atc. \
2) Notice the second column--"identifier". \


**On the other hand, gat-gat and atc-atc means same structure**. \
```{r engine='bash', eval=TRUE, echo=TRUE}
awk -F'\t' '$1 ~ /^gat.*gat/' GATA3_peak_161win_with_motif_1_RSAT_dyad.txt | sort -k8,8nr
```

```{r engine='bash', eval=TRUE, echo=TRUE}
awk -F'\t' '$1 ~ /^atc.*atc/' GATA3_peak_161win_with_motif_1_RSAT_dyad.txt | sort -k8,8nr
```

Extract the pattern info we need. \
```{r engine='R', eval=TRUE, echo=TRUE}
library(Biostrings)

process_and_subset_RSAT <- function(file_path, pattern1, pattern2, number) {
  # Read the file
  input_data <- read.table(file_path, header = FALSE, sep = "\t")

  # Split the first column into components
  components_list <- strsplit(input_data$V1, "n\\{|\\}")

  processed_data <- data.frame(
    first = sapply(components_list, function(x) x[1]),
    dyad_distance = as.numeric(sapply(components_list, function(x) x[2])),
    second = sapply(components_list, function(x) x[3]),
    ratio = input_data$V8 # ratio
  )
  # patterns to DNAstring
  pattern1<-DNAString(pattern1)
  pattern2<-DNAString(pattern2)
  # Get the reverse complement of the patterns
  rc_pattern1 <- reverseComplement(pattern1)
  rc_pattern2 <- reverseComplement(pattern2)

  # Subset the dataframe based on the specified patterns and their reverse complements
  if (pattern1 == pattern2) {
    # Get the reverse complement of the patterns
    rc_pattern1 <- reverseComplement(pattern1)
    rc_pattern2 <- reverseComplement(pattern2)

    # Subset the dataframe based on the specified patterns and their reverse complements
    dyad_structure <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
    dyad_structure_rc <- processed_data[grepl(rc_pattern1, processed_data$first, ignore.case = TRUE) & grepl(rc_pattern2, processed_data$second, ignore.case = TRUE), ]
    
    output_data <- rbind(dyad_structure, dyad_structure_rc)
  } else {
    # If patterns are not the same, only subset based on pattern1 and pattern2
    output_data <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
  }
    
  # Order by descending ratio
  output_data <- output_data[order(-output_data$ratio), ]

  # Add the relative distance column
  output_data$relative_distance <- output_data$dyad_distance + number

  return(output_data)
}


GAT_GAT <- process_and_subset_RSAT("./GATA3_peak_161win_with_motif_1_RSAT_dyad.txt", "GAT", "GAT", 3)
GAT_ATC <- process_and_subset_RSAT("./GATA3_peak_161win_with_motif_1_RSAT_dyad.txt", "GAT", "ATC", 5)

nrow(GAT_GAT)
head(GAT_GAT)
nrow(GAT_ATC)
head(GAT_ATC)
```

The GAT_GAT will be the red trace, since the second GAT is on same strand relative to the first GAT; Similarly, the GAT_ATC will be the blue trace,as the second ATC is on opposite strand relative to the first GAT. \

```{r engine='R', eval=TRUE, echo=TRUE}
GAT_GAT$query_status="same_strand_GAT"
GAT_ATC$query_status="opposite_strand_GAT"
df.plot=rbind(GAT_GAT, GAT_ATC)
str(df.plot)

unique(df.plot$query_status)
#[1] "same_strand_GAT"     "opposite_strand_GAT"
head(df.plot)
df.plot$query_status = factor(df.plot$query_status, levels = c("same_strand_GAT", "opposite_strand_GAT"))
nrow(df.plot)
#42
summary(df.plot)
```

xyplot \
```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
  xyplot(ratio ~ relative_distance,
         data = df.plot, 
         groups = query_status,
         #auto.key=TRUE,
         #auto.key = list(space = "right", lines=F, points=TRUE, cex = 1),
         auto.key=list(space="right", points=TRUE),
                       #title="2nd 3mer relative to the anchor", cex.title=1),
         aspect = 1,
         xlim=c(0,30),
         ylim=c(0, 200),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest GAT to closest GAT",
         ylab="RSAT obs/exp Ratio",
         main="GATA3 peak with motif1",
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
           
                                      panel.xyplot(x, y, 
                                                   col=c("orange","darkgreen"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
  })


```


Loop through RSAT results use the other positive controls, extract the relative dyad patterns and make a xy/barchart: \
```{r engine='R', eval=F, echo=TRUE}
library(Biostrings)
library(lattice)
library(latticeExtra)

#function
process_and_subset_RSAT <- function(file_path, pattern1, pattern2, number) {
  # Read the file
  input_data <- read.table(file_path, header = FALSE, sep = "\t")

  # Split the first column into components
  components_list <- strsplit(input_data$V1, "n\\{|\\}")

  processed_data <- data.frame(
    first = sapply(components_list, function(x) x[1]),
    dyad_distance = as.numeric(sapply(components_list, function(x) x[2])),
    second = sapply(components_list, function(x) x[3]),
    ratio = input_data$V8 # ratio
  )
  # patterns to DNAstring
  pattern1<-DNAString(pattern1)
  pattern2<-DNAString(pattern2)
  # Get the reverse complement of the patterns
  rc_pattern1 <- reverseComplement(pattern1)
  rc_pattern2 <- reverseComplement(pattern2)

  # Subset the dataframe based on the specified patterns and their reverse complements
  if (pattern1 == pattern2) {
    # Get the reverse complement of the patterns
    rc_pattern1 <- reverseComplement(pattern1)
    rc_pattern2 <- reverseComplement(pattern2)

    # Subset the dataframe based on the specified patterns and their reverse complements
    dyad_structure <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
    dyad_structure_rc <- processed_data[grepl(rc_pattern1, processed_data$first, ignore.case = TRUE) & grepl(rc_pattern2, processed_data$second, ignore.case = TRUE), ]
    
    output_data <- rbind(dyad_structure, dyad_structure_rc)
  } else {
    # If patterns are not the same, only subset based on pattern1 and pattern2
    output_data <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
  }
    
  # Order by descending ratio
  output_data <- output_data[order(-output_data$ratio), ]

  # Add the relative distance column
  output_data$relative_distance <- output_data$dyad_distance + number

  return(output_data)
}

#loop through files
for (dyad.results in Sys.glob(file.path("./GATA3_peak_161win_with_motif_*_RSAT_dyad.txt")))  {
    print(dyad.results)
    motif.name = paste0("motif", strsplit((strsplit(strsplit(dyad.results, "/")[[1]][length(strsplit(dyad.results, "/")[[1]])], 'GATA3_peak_161win_with_motif_')[[1]][2]), "_RSAT_dyad.txt")[[1]][1])
    print(motif.name)
    GAT_GAT <- process_and_subset_RSAT(dyad.results, "GAT", "GAT", 3)
    GAT_ATC <- process_and_subset_RSAT(dyad.results, "GAT", "ATC", 5)
    nrow(GAT_GAT)
    head(GAT_GAT)
    nrow(GAT_ATC)
    head(GAT_ATC)
    GAT_GAT$query_status="same_strand_GAT"
    GAT_ATC$query_status="opposite_strand_GAT"
    df.plot=rbind(GAT_GAT, GAT_ATC)
    str(df.plot)

    unique(df.plot$query_status)
    #[1] "same_strand_GAT"     "opposite_strand_GAT"
    head(df.plot)
    df.plot$query_status = factor(df.plot$query_status, levels = c("same_strand_GAT", "opposite_strand_GAT"))
    nrow(df.plot)

    summary(df.plot)
    pdf(paste0('xy_RSAT_dyad_closest_2nd_GAT_to_closest_1st_GAT_GATA3_peak_with_', motif.name, '.pdf'), width=15,height=5)
print(
  xyplot(ratio ~ relative_distance,
         data = df.plot, 
         groups = query_status,
         #auto.key=TRUE,
         #auto.key = list(space = "right", lines=F, points=TRUE, cex = 1),
         auto.key=list(space="right", points=TRUE),
                       #title="2nd 3mer relative to the anchor", cex.title=1),
         aspect = 1,
         xlim=c(0,30),
         ylim=c(0, 200),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest GAT to closest GAT",
         ylab="RSAT obs/exp Ratio",
         main=paste0("GATA3 peak with ", motif.name),
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
           
                                      panel.xyplot(x, y, 
                                                   col=c("orange","darkgreen"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
  })
)
dev.off()
}
```


### RSAT--motif5
In the previous analysis, we extracted dyad structures anchored at "GAT." However, we have discussed the sensitivity of RSAT analysis to structures with two reverse-complement dyads. For motif5 analysis, we aim to focus on structures anchored specifically at "ATC" to ensure we identify the correct structure. \
```{r engine='R', eval=TRUE, echo=TRUE}
library(Biostrings)

process_and_subset_RSAT <- function(file_path, pattern1, pattern2, number) {
  # Read the file
  input_data <- read.table(file_path, header = FALSE, sep = "\t")

  # Split the first column into components
  components_list <- strsplit(input_data$V1, "n\\{|\\}")

  processed_data <- data.frame(
    first = sapply(components_list, function(x) x[1]),
    dyad_distance = as.numeric(sapply(components_list, function(x) x[2])),
    second = sapply(components_list, function(x) x[3]),
    ratio = input_data$V8 # ratio
  )
  # patterns to DNAstring
  pattern1<-DNAString(pattern1)
  pattern2<-DNAString(pattern2)
  # Get the reverse complement of the patterns
  rc_pattern1 <- reverseComplement(pattern1)
  rc_pattern2 <- reverseComplement(pattern2)

  # Subset the dataframe based on the specified patterns and their reverse complements
  if (pattern1 == pattern2) {
    # Get the reverse complement of the patterns
    rc_pattern1 <- reverseComplement(pattern1)
    rc_pattern2 <- reverseComplement(pattern2)

    # Subset the dataframe based on the specified patterns and their reverse complements
    dyad_structure <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
    dyad_structure_rc <- processed_data[grepl(rc_pattern1, processed_data$first, ignore.case = TRUE) & grepl(rc_pattern2, processed_data$second, ignore.case = TRUE), ]
    
    output_data <- rbind(dyad_structure, dyad_structure_rc)
  } else {
    # If patterns are not the same, only subset based on pattern1 and pattern2
    output_data <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
  }
    
  # Order by descending ratio
  output_data <- output_data[order(-output_data$ratio), ]

  # Add the relative distance column
  output_data$relative_distance <- output_data$dyad_distance + number

  return(output_data)
}


ATC_GAT <- process_and_subset_RSAT("./GATA3_peak_161win_with_motif_5_RSAT_dyad.txt", "ATC", "GAT", 1)
ATC_ATC <- process_and_subset_RSAT("./GATA3_peak_161win_with_motif_5_RSAT_dyad.txt", "ATC", "ATC", 3)

nrow(ATC_GAT)
head(ATC_GAT)
nrow(ATC_ATC)
head(ATC_ATC)
```

```{r engine='R', eval=TRUE, echo=TRUE}
ATC_ATC$query_status="same_strand_ATC"
ATC_GAT$query_status="opposite_strand_ATC"
df.plot=rbind(ATC_ATC, ATC_GAT)
str(df.plot)

unique(df.plot$query_status)

head(df.plot)
df.plot$query_status = factor(df.plot$query_status, levels = c("same_strand_ATC", "opposite_strand_ATC"))
nrow(df.plot)
#42
summary(df.plot)
```

xyplot \
```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
#pdf(paste0('xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATC_GATA3_peak_with_motif5.pdf'), width=10,height=5)
#print(
  xyplot(ratio ~ relative_distance,
         data = df.plot, 
         groups = query_status,
         #auto.key=TRUE,
         #auto.key = list(space = "right", lines=F, points=TRUE, cex = 1),
         auto.key=list(space="right", points=TRUE),
                       #title="2nd 3mer relative to the anchor", cex.title=1),
         aspect = 1,
         xlim=c(0,30),
         ylim=c(0, 300),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest ATC to closest ATC",
         ylab="RSAT obs/exp Ratio",
         main="GATA3 peak with motif5",
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.symbol = list(col=c("#8B4513", "#145A8C"), pch=18, lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
           
                                      panel.xyplot(x, y, 
                                                   col=c("#8B4513", "#145A8C"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
  })
#)
#dev.off()

```


# Comparison between RSAT and customized analysis

For the customized analysis: \

1) Merge the occurrences of the anchored GAT on both the plus and minus strands. \

2) Determine the second closest GAT relative to the strandedness of the anchored GAT. For example, if anchoring at GAT (regardless of its strand), the "minus-GAT" trace should be the sum of the occurrences of "+GAT" anchored at -GAT and "-GAT" anchored at +GAT. \

3) Calculate the relative frequencies (y-axis in plots) as the actual occurrences of the pattern minus the frequencies from the DHS negative control. \

```{r engine='R', eval=F, echo=TRUE}
# define function
calculate_actual_frequency <- function(data) {
  # Use table() to create a frequency table
  actual_frequencies <- table(data)/length(data)
  result <- data.frame(value = names(actual_frequencies), actual_freq = as.vector(actual_frequencies))
  return(result)
}


my_motifs = c("motif1", "motif4","motif2", "motif6", "motif5")
for (motif in my_motifs) {
  print(motif)
  #GATA peaks
  df.plot.GATA = data.frame(matrix(nrow = 0, ncol = 5))     
  colnames(df.plot.GATA) = c("dis","anchor_status", "query_status","abs.dis", "actual_freq")
  for (closest_2nd_dis in Sys.glob(file.path(paste0("./closest.2nd*GAT.to.1st*GAT.GATA3.", motif, ".bed")))) {
    print(closest_2nd_dis)
    anchor_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.*.to.1st.')[[1]][2]), paste0(".GATA3.", motif, ".bed"))[[1]][1]
    print(anchor_status)
    query_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.')[[1]][2]), paste0(".to.1st.*.GATA3.", motif, ".bed"))[[1]][1]
    print(query_status)
    temp = as.data.frame(cbind(read.table(closest_2nd_dis, header=F, comment.char='')[,11], anchor_status, query_status)) 
    colnames(temp) = c("dis", "anchor_status", "query_status")
    temp$dis=as.integer(temp$dis)
    temp$abs.dis=abs(temp$dis)
    actual_frequencies = calculate_actual_frequency(temp$abs.dis)
    temp1= merge(temp, actual_frequencies, by.x = "abs.dis", by.y = "value", all.x = TRUE)
    df.plot.GATA = rbind(df.plot.GATA,temp1)
  }
  df.plot.GATA$anchor_status = factor(df.plot.GATA$anchor_status, levels = c("plus.GAT", "minus.GAT"))
  df.plot.GATA$query_status = factor(df.plot.GATA$query_status, levels = c("plus.GAT", "minus.GAT"))
  uniq.df.plot.GATA=df.plot.GATA[!duplicated(df.plot.GATA), ]
  
  
  #DHS regions
  df.plot.DHS = data.frame(matrix(nrow = 0, ncol = 5))     
colnames(df.plot.DHS) = c("dis","anchor_status", "query_status","abs.dis", "actual_freq_neg")
for (closest_2nd_dis in Sys.glob(file.path("./closest.2nd*GAT.to.1st*GAT.indep.DHS.bed"))) {
    print(closest_2nd_dis)
    anchor_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.*.to.1st.')[[1]][2]), ".indep.DHS.bed")[[1]][1]
    print(anchor_status)
    query_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.')[[1]][2]), ".to.1st.*.indep.DHS.bed")[[1]][1]
    print(query_status)
    temp = as.data.frame(cbind(read.table(closest_2nd_dis, header=F, comment.char='')[,11], anchor_status, query_status)) 
    colnames(temp) = c("dis", "anchor_status", "query_status")
    temp$dis=as.integer(temp$dis)
    temp$abs.dis=abs(temp$dis)
    actual_frequency = calculate_actual_frequency(temp$abs.dis)
    temp1= merge(temp, actual_frequency, by.x = "abs.dis", by.y = "value", all.x = TRUE)
    df.plot.DHS = rbind(df.plot.DHS, temp1)
}
    colnames(df.plot.DHS)[5]="actual_freq_DHS"
    df.plot.DHS$anchor_status = factor(df.plot.DHS$anchor_status, levels = c("plus.GAT", "minus.GAT"))
    df.plot.DHS$query_status = factor(df.plot.DHS$query_status, levels = c("plus.GAT", "minus.GAT"))
    uniq.df.plot.DHS=df.plot.DHS[!duplicated(df.plot.DHS), ]
    #nrow(uniq.df.plot.DHS) #[1] 2859
  
  #calculate the relative frequency
    #by subtraction of actual frequency between GATA3 peaks and DHS regions
    df.plot=merge(uniq.df.plot.GATA, uniq.df.plot.DHS, by=c("abs.dis", "dis", "anchor_status", "query_status"), all.x = TRUE)
    df.plot$rel_freq <- ifelse(is.na(df.plot$actual_freq_DHS), NA, df.plot$actual_freq - df.plot$actual_freq_DHS)
    df.plot$strand_relationship <- ifelse(df.plot$anchor_status == df.plot$query_status,
                                              "same_strand_GAT", "opposite_strand_GAT")
    
    df.plot$strand_relationship = factor(df.plot$strand_relationship, levels = c("same_strand_GAT", "opposite_strand_GAT"))
    
library(lattice)
library(latticeExtra)
pdf(paste0('xy_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_', motif, '_compare_to_DHS.pdf'), width=15,height=5)
print(xyplot(rel_freq ~ abs.dis, 
         data = df.plot, 
         groups = strand_relationship,
         auto.key = list(space = "right", lines=TRUE, points=FALSE, cex = 1),
         aspect = 1,
         xlim=c(0,50),
         ylim=c(0, 0.3),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest GAT to closest GAT",
         ylab="Frequency relative to DHS regions",
         main=paste0("GATA3 peak with ", motif),
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.line = list(col=c("pink", "skyblue"), lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) {panel.densityplot(x, data = df.plot, 
                                                        from=0, 
                                                        to=50, 
                                                        lty = c(1),
                                                        lwd=2, 
                                                        darg=list(bw = "nrd0", kernel="gaussian"),
                                                        type = "count",
                                                        col=c("pink","skyblue"), ...)
                                      panel.xyplot(x, y, 
                                                   col=c("red","blue"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                      
  })
)
dev.off()

png(paste0('xy_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
print(xyplot(rel_freq ~ abs.dis | anchor_status, 
         #data = df.plot[!duplicated(df.plot), ],
         data = df.plot, 
         groups = query_status,
         auto.key = list(space = "right", lines=TRUE, points=FALSE, cex = 1),
         aspect = 1,
         xlim=c(0,50),
         ylim=c(0, 0.3),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest GAT to closest GAT",
         ylab="Frequency relative to DHS regions",
         main=paste0("GATA3 peak with ", motif),
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.line = list(col=c("pink", "skyblue"), lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) {panel.densityplot(x, data = df.plot, 
                                                        from=0, 
                                                        to=50, 
                                                        lty = c(1),
                                                        lwd=2, 
                                                        darg=list(bw = "nrd0", kernel="gaussian"),
                                                        type = "count",
                                                        col=c("pink","skyblue"), ...)
                                      panel.xyplot(x, y, 
                                                   col=c("red","blue"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                      
  })
)
dev.off()
}


```


```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of GATA3 peak with motif1 relative to the DHS regions: 3mer structure"}
library(knitr)
knitr::include_graphics("./xy_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_motif1_compare_to_DHS.png") 
```
The plot generated using the above code has double points at the same distance with same strand info. This is because the plus.GAT-minus.GAT and minus.GAT-plus.GAT are both labeled as "opposite_strand_GAT" and the relative frequency is slightly different (although pretty close). \

See the plotting data frame below: \

```{r engine='R', eval=F, echo=TRUE}
abs.dis dis anchor_status query_status  actual_freq actual_freq_DHS
1       1   1      plus.GAT    minus.GAT 0.0008025682    0.0008209464
2       1   1     minus.GAT     plus.GAT 0.0009630046    0.0008557308
3       2   2      plus.GAT    minus.GAT 0.0119582665    0.0027248432
4       2   2     minus.GAT     plus.GAT 0.0127598106    0.0026021201
5       3   3      plus.GAT     plus.GAT 0.0300938929    0.0162763486
6       3   3      plus.GAT    minus.GAT 0.0760032103    0.1039283157
       rel_freq strand_relationship
1 -1.837814e-05 opposite_strand_GAT
2  1.072738e-04 opposite_strand_GAT
3  9.233423e-03 opposite_strand_GAT
4  1.015769e-02 opposite_strand_GAT
5  1.381754e-02     same_strand_GAT
6 -2.792511e-02 opposite_strand_GAT
```

This is not ideal. So I will modify the code: instead of calculating the actual frequency for each files, I will combine the file together, create the label relative to strand info, then calculate the actual frequency. \

```{r engine='R', eval=F, echo=TRUE}
# define function
calculate_actual_frequency <- function(data) {
  # Use table() to create a frequency table
  actual_frequencies <- table(data)/length(data)
  result <- data.frame(value = names(actual_frequencies), actual_freq = as.vector(actual_frequencies))
  return(result)
}


my_motifs = c("motif1", "motif4","motif2", "motif6", "motif5")
for (motif in my_motifs) {
  print(motif)
  #GATA peaks
  df.plot.GATA = data.frame(matrix(nrow = 0, ncol = 4))     
  colnames(df.plot.GATA) = c("dis","anchor_status", "query_status","abs.dis")
  for (closest_2nd_dis in Sys.glob(file.path(paste0("./closest.2nd*GAT.to.1st*GAT.GATA3.", motif, ".bed")))) {
    print(closest_2nd_dis)
    anchor_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.*.to.1st.')[[1]][2]), paste0(".GATA3.", motif, ".bed"))[[1]][1]
    print(anchor_status)
    query_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.')[[1]][2]), paste0(".to.1st.*.GATA3.", motif, ".bed"))[[1]][1]
    print(query_status)
    temp = as.data.frame(cbind(read.table(closest_2nd_dis, header=F, comment.char='')[,11], anchor_status, query_status)) 
    colnames(temp) = c("dis", "anchor_status", "query_status")
    temp$dis=as.integer(temp$dis)
    temp$abs.dis=abs(temp$dis)
    df.plot.GATA = rbind(df.plot.GATA,temp)
  }
 
  df.plot.GATA$anchor_status = factor(df.plot.GATA$anchor_status, levels = c("plus.GAT", "minus.GAT"))
  df.plot.GATA$query_status = factor(df.plot.GATA$query_status, levels = c("plus.GAT", "minus.GAT"))
  df.plot.GATA$strand_relationship <- ifelse(df.plot.GATA$anchor_status == df.plot.GATA$query_status,
                                              "same_strand_GAT", "opposite_strand_GAT")
  df.plot.GATA$strand_relationship = factor(df.plot.GATA$strand_relationship, levels = c("same_strand_GAT", "opposite_strand_GAT"))
  
  temp.g1=df.plot.GATA[df.plot.GATA$strand_relationship=="same_strand_GAT",]
  actual_frequency_same_strand = calculate_actual_frequency(temp.g1$abs.dis)
  temp.g2=df.plot.GATA[df.plot.GATA$strand_relationship=="opposite_strand_GAT",]
  actual_frequency_oppo_strand = calculate_actual_frequency(temp.g2$abs.dis)
  
  df.plot.GATA1=rbind(merge(temp.g1, actual_frequency_same_strand, by.x = "abs.dis", by.y = "value", all.x = TRUE), merge(temp.g2, actual_frequency_oppo_strand, by.x = "abs.dis", by.y = "value", all.x = TRUE))
  uniq.df.plot.GATA=df.plot.GATA1[!duplicated(df.plot.GATA1), ]
  

  
  #DHS regions
  df.plot.DHS = data.frame(matrix(nrow = 0, ncol = 4))     
colnames(df.plot.DHS) = c("dis","anchor_status", "query_status","abs.dis")
for (closest_2nd_dis in Sys.glob(file.path("./closest.2nd*GAT.to.1st*GAT.indep.DHS.bed"))) {
    print(closest_2nd_dis)
    anchor_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.*.to.1st.')[[1]][2]), ".indep.DHS.bed")[[1]][1]
    print(anchor_status)
    query_status =strsplit((strsplit(strsplit(closest_2nd_dis, "/")[[1]][length(strsplit(closest_2nd_dis, "/")[[1]])], 'closest.2nd.')[[1]][2]), ".to.1st.*.indep.DHS.bed")[[1]][1]
    print(query_status)
    temp = as.data.frame(cbind(read.table(closest_2nd_dis, header=F, comment.char='')[,11], anchor_status, query_status)) 
    colnames(temp) = c("dis", "anchor_status", "query_status")
    temp$dis=as.integer(temp$dis)
    temp$abs.dis=abs(temp$dis)
    df.plot.DHS = rbind(df.plot.DHS, temp)
}

  df.plot.DHS$anchor_status = factor(df.plot.DHS$anchor_status, levels = c("plus.GAT", "minus.GAT"))
  df.plot.DHS$query_status = factor(df.plot.DHS$query_status, levels = c("plus.GAT", "minus.GAT"))
  df.plot.DHS$strand_relationship <- ifelse(df.plot.DHS$anchor_status == df.plot.DHS$query_status,
                                              "same_strand_GAT", "opposite_strand_GAT")
  df.plot.DHS$strand_relationship = factor(df.plot.DHS$strand_relationship, levels = c("same_strand_GAT", "opposite_strand_GAT"))
  
  temp.g1=df.plot.DHS[df.plot.DHS$strand_relationship=="same_strand_GAT",]
  actual_frequency_same_strand = calculate_actual_frequency(temp.g1$abs.dis)
  temp.g2=df.plot.DHS[df.plot.DHS$strand_relationship=="opposite_strand_GAT",]
  actual_frequency_oppo_strand = calculate_actual_frequency(temp.g2$abs.dis)
  
  df.plot.DHS1=rbind(merge(temp.g1, actual_frequency_same_strand, by.x = "abs.dis", by.y = "value", all.x = TRUE), merge(temp.g2, actual_frequency_oppo_strand, by.x = "abs.dis", by.y = "value", all.x = TRUE))
  uniq.df.plot.DHS=df.plot.DHS1[!duplicated(df.plot.DHS1), ] #nrow(uniq.df.plot.DHS) #[1] 2859
  colnames(uniq.df.plot.DHS)[6]="actual_freq_DHS"
  
  #calculate the relative frequency
    #by subtraction of actual frequency between GATA3 peaks and DHS regions
    df.plot1=merge(uniq.df.plot.GATA, uniq.df.plot.DHS, by=c("abs.dis", "dis", "anchor_status", "query_status", "strand_relationship"), all.x = TRUE)
    df.plot1$rel_freq <- ifelse(is.na(df.plot1$actual_freq_DHS), NA, df.plot1$actual_freq - df.plot1$actual_freq_DHS)
   
    df.plot=df.plot1[, c(1,2,5,6,7,8)] #1104
    df.plot=df.plot[!duplicated(df.plot), ] #658
    
    
library(lattice)
library(latticeExtra)
pdf(paste0('xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_', motif, '_compare_to_DHS.pdf'), width=15,height=5)
print(xyplot(rel_freq ~ abs.dis, 
         data = df.plot, 
         groups = strand_relationship,
         auto.key=list(space="right", points=TRUE),
         aspect = 1,
         xlim=c(0,50),
         ylim=c(0, 0.3),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest GAT to closest GAT",
         ylab="Frequency relative to DHS regions",
         main=paste0("GATA3 peak with ", motif),
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.symbol = list(col=c("red", "blue"), pch=18, lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
           
                                      panel.densityplot(x, data = df.plot, 
                                                        from=0, 
                                                        to=50, 
                                                        lty = c(1),
                                                        lwd=2, 
                                                        darg=list(bw = "nrd0", kernel="gaussian"),
                                                        type = "count",
                                                        col=c("pink","skyblue"), ...)
                                      panel.xyplot(x, y, 
                                                   col=c("red","blue"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      
                                      
  })
)
dev.off()


png(paste0('xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
print(xyplot(rel_freq ~ abs.dis, 
         data = df.plot, 
         groups = strand_relationship,
         auto.key=list(space="right", points=TRUE),
         aspect = 1,
         xlim=c(0,50),
         ylim=c(0, 0.3),
         #type = c('p', 'smooth'),
         xlab = "distance (bp) from 2nd closest GAT to closest GAT",
         ylab="Frequency relative to DHS regions",
         main=paste0("GATA3 peak with ", motif),
         between=list(y=1.0),
         scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
         par.settings = list(superpose.symbol = list(col=c("red", "blue"), pch=18, lwd=2), strip.background=list(col="grey85")),
         panel = function(x,y,...) { panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                     panel.densityplot(x, data = df.plot, 
                                                        from=0, 
                                                        to=50, 
                                                        lty = c(1),
                                                        lwd=2, 
                                                        darg=list(bw = "nrd0", kernel="gaussian"),
                                                        type = "count",
                                                        col=c("pink","skyblue"), ...)
                                      panel.xyplot(x, y, 
                                                   col=c("red","blue"), 
                                                   pch=18, 
                                                   cex=0.6,...)
                                      
                                      
  })
)
dev.off()
}
```

Now the plotting data frame contains only single relative frequency value grouped by strand relationship. \
```{r engine='R', eval=F, echo=TRUE}
 abs.dis dis strand_relationship  actual_freq actual_freq_DHS      rel_freq
1        1   1 opposite_strand_GAT 0.0008827896    0.0008383401  4.444953e-05
3        2   2 opposite_strand_GAT 0.0123590546    0.0026634763  9.695578e-03
5        3   3     same_strand_GAT 0.0286505357    0.0162428392  1.240770e-02
6        3   3 opposite_strand_GAT 0.0796516994    0.1027927204 -2.314102e-02
9        4   4     same_strand_GAT 0.0108743630    0.0088636999  2.010663e-03
10       4   4 opposite_strand_GAT 0.0085871353    0.0040607098  4.526426e-03
```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of GATA3 peak with motif1 relative to the DHS regions: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_motif1_compare_to_DHS.png") 
```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of GATA3 peak with motif2 relative to the DHS regions: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_motif2_compare_to_DHS.png") 
```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of GATA3 peak with motif4 relative to the DHS regions: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_motif4_compare_to_DHS.png") 
```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of GATA3 peak with motif5 relative to the DHS regions: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_motif5_compare_to_DHS.png") 
```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of GATA3 peak with motif6 relative to the DHS regions: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy2_closest_2nd_GAT_to_closest_1st_GAT_to_GATA3_pos_motif6_compare_to_DHS.png") 
```


# Automate analysis to go through the prioritized 3mers

In our previous analysis, we placed emphasis on certain 3-mers by assessing their enrichment in GATA3 peaks relative to DHS regions. This enrichment was determined by calculating the differences in cumulative distribution function (CDF) fractions at a specified "closed" distance (both 16bp and 20bp yield the same 3-mer cluster). \

These prioritized 3mer includes "AAA" "TAA" "ATA" "TTA" "AAT" "TAT" "GAT" "ATT" "TTT" "ATC". \

Here, I want to \
1) Extract patterns from RSAT analysis that related to these 3mer combination and compare with the above analysis. \

2) Automate customized analysis to go through the prioritized 3mers to measure the 2nd 3mer distance to the anchored 3mer.  \

First use GATA3 peaks with motif1 to do some test run, then perform the analysis to all 5 positive peak sets. Finally we want to apply to the peaks without motifs. \


## RSAT-dyad analysis -- prioritized 3mer

### Enrichment xy plot

Load the package, and the function to process the RSAT results file: \
```{r engine='R', eval=F, echo=TRUE}
library(Biostrings)
process_and_subset_RSAT <- function(file_path, pattern1, pattern2, number) {
  # Read the file
  input_data <- read.table(file_path, header = FALSE, sep = "\t")

  # Split the first column into components
  components_list <- strsplit(input_data$V1, "n\\{|\\}")

  processed_data <- data.frame(
    first = sapply(components_list, function(x) x[1]),
    dyad_distance = as.numeric(sapply(components_list, function(x) x[2])),
    second = sapply(components_list, function(x) x[3]),
    ratio = input_data$V8 # ratio
  )
  # patterns to DNAstring
  pattern1<-DNAString(pattern1)
  pattern2<-DNAString(pattern2)
  # Get the reverse complement of the patterns
  rc_pattern1 <- reverseComplement(pattern1)
  rc_pattern2 <- reverseComplement(pattern2)

  # Subset the dataframe based on the specified patterns and their reverse complements
  if (pattern1 == pattern2) {
    # Get the reverse complement of the patterns
    rc_pattern1 <- reverseComplement(pattern1)
    rc_pattern2 <- reverseComplement(pattern2)

    # Subset the dataframe based on the specified patterns and their reverse complements
    dyad_structure <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
    dyad_structure_rc <- processed_data[grepl(rc_pattern1, processed_data$first, ignore.case = TRUE) & grepl(rc_pattern2, processed_data$second, ignore.case = TRUE), ]
    
    output_data <- rbind(dyad_structure, dyad_structure_rc)
  } else {
    # If patterns are not the same, only subset based on pattern1 and pattern2
    output_data <- processed_data[grepl(pattern1, processed_data$first, ignore.case = TRUE) & grepl(pattern2, processed_data$second, ignore.case = TRUE), ]
  }
    
  # Order by descending ratio
  output_data <- output_data[order(-output_data$ratio), ]

  # Add the relative distance column
  output_data$relative_distance <- output_data$dyad_distance + number

  return(output_data)
}
```

In the provided function, **pattern1** represents the anchored dyad, **pattern2** denotes the other half dyad, and **number** signifies the user-defined distance (representing the relative separation between two zinc fingers, with "G" serving as the single resolution) when there is no spacing between each dyad. \

For AAT and ATT, there is two possible relative "G/C". One is (gat)AAT/ATT(atc), one is AAT(c)/(g)ATT. \
I have examined the Information Content (IC) in all Sequence logos of the Information Content Matrix, and examined the letter-probability matrix to determine which configiration is more common/more likely to observe. \
Overall, AAT(c)/(g)ATT have higher IC compared to (gat)AAT/ATT(atc). \
I will use AAT(c)/(g)ATT to anchor at the 'G/C' base for measuring the relative distance between the two zinc fingers. \



I've created a file that simplifies the computation of the 'number' for any given pair of dyads. It operates by adding the corresponding numbers associated with the anchor (pattern1) or query (pattern2) pattern. \
```{r engine='R', eval=TRUE, echo=TRUE}
#pattern_anchor_at_G_compute_dis.csv
read.csv('pattern_anchor_at_G_compute_dis.csv')
```


```{r engine='R', eval=F, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)

my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("AAA", "TAA" ,"ATA" ,"TTA", "AAT", "TAT", "GAT", "ATT", "TTT", "ATC")
Query_dyad =c("AAA", "TAA" ,"ATA" ,"TTA", "AAT", "TAT", "GAT", "ATT", "TTT", "ATC")

compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      pdf(paste0('test_xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.pdf'), width=10,height=6)
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(0,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                   main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}
```

test: \
```{r engine='R', eval=F, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1")
Anchor_dyad = c("GAT")
Query_dyad =c("GAT")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      pdf(paste0('test_xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.pdf'), width=10,height=6)
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(0,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}
```
test2: \
```{r engine='R', eval=F, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1")
Anchor_dyad = c("TAA")
Query_dyad =c("AAA")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      pdf(paste0('test_xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.pdf'), width=10,height=6)
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(0,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}
```

Anchor at one of the top 10 prioritized 3-mers, then query the remaining 10 3-mers on either the same strand or the opposite strand. This generates a 10x10=100 enrichment graph for each of the five peak data sets, resulting in a total of 500 enrichment graphs. \

### Ranking dyad-structure

Another method to identify the most enriched structure within each peak dataset is by ranking the files (from the 5 peak sets) based on the observed-to-expected (obs/exp) ratio. This allows us to determine which structural motif is enriched, followed by a search for the corresponding enrichment graph. \

Files generated: \
GATA3_peak_161win_with_motif_1_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_2_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_4_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_5_RSAT_dyad.txt \
GATA3_peak_161win_with_motif_6_RSAT_dyad.txt \

**GATA3 peak with motif1** \

```{r engine='bash', eval=TRUE, echo=TRUE}
cat GATA3_peak_161win_with_motif_1_RSAT_dyad.txt | sort -k8,8nr | head -3
```


**GATA3 peak with motif2** \

```{r engine='bash', eval=TRUE, echo=TRUE}
cat GATA3_peak_161win_with_motif_2_RSAT_dyad.txt | sort -k8,8nr | head -3
```

**GATA3 peak with motif4** \
```{r engine='bash', eval=TRUE, echo=TRUE}
cat GATA3_peak_161win_with_motif_4_RSAT_dyad.txt | sort -k8,8nr | head -8
```
**GATA3 peak with motif5** \
```{r engine='bash', eval=TRUE, echo=TRUE}
cat GATA3_peak_161win_with_motif_5_RSAT_dyad.txt | sort -k8,8nr | head -5

```
**GATA3 peak with motif6** \
```{r engine='bash', eval=TRUE, echo=TRUE}
cat GATA3_peak_161win_with_motif_6_RSAT_dyad.txt | sort -k8,8nr | head -3
```

In the above 5 GATA3 peak data sets, it seems that **AGA-TAA**, **GAT-ATC**, **ATA-ATC**, **ATC-ATC**, **TAG-ATA**, **ATC-GAT**, **ATC-ATA** and **GAT-ATA** are enriched in GATA3 peaks contains GATA3 motifs. \

#### AGA-TAA
Unfortunately, **AGA** is not included in our prioritized list, but it is ranked just after TTT/AAA. Therefore, we can include an analysis of this 3-mer here. \
And in our customized analysis, we might also include AGA/TCT to our prioritized 3mer list. \

```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("AGA")
Query_dyad =c("TAA")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      pdf(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.pdf'), width=10,height=6)
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif4: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_TAA_to_closest_1st_AGA_to_GATA3_pos_motif_4_compare_to_DHS.png") 
```

All enrichment graphs show enrichment of a dyad structure with AGA 6bp distal from the opposite strand TAA, which is a [AGA][TTA]TC. With a relative distance from G to C being 6bp. \

We did not observe enrichment at a relative distance of 0 between AGA and TAA on the same strand. This is because a relative distance of 0 between two zinc fingers implies that only one zinc finger is binding in that location, indicating the absence of a dyad structure. Similarly, when we did not observe enrichment for the AGATAA structure in our graph, it's because AGATAA is considered a single binding site, rather than two separate motifs. \


#### GAT-ATC

```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("GAT")
Query_dyad =c("ATC")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

**GATA3 peak with motif1** \
```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif1: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_GAT_to_GATA3_pos_motif_1_compare_to_DHS.png") 
```
For GATA3 peaks with motif1, we have seen an enriched dyad structure of a GAT with 8bp relative distance to its same strand ATC. \
This is same as the RSAT defined GATn{3}ATC which rank as second highest ratio. And also match the motif1 PWMs/seqlogo. \


**GATA3 peak with motif2** \

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif2: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_GAT_to_GATA3_pos_motif_2_compare_to_DHS.png") 
```
For GATA3 peaks with motif2, we have seen an enriched dyad structure of a GAT with 9bp relative distance to its same strand ATC. \
This is same as the RSAT defined GATn{4}ATC which rank as second highest ratio. And also match the motif2 PWMs/seqlogo. \


**GATA3 peak with motif4** \
```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif4: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_GAT_to_GATA3_pos_motif_4_compare_to_DHS.png") 
```

For GATA3 peaks with motif4, we have seen an enriched dyad structure of a GAT with 8bp relative distance to its opposite strand ATC (same as the same strand GAT). \
This is same as the RSAT defined atcn{5}atc/gatn{5}gat which rank as second highest ratio. And also match the motif4 PWMs/seqlogo. \

**GATA3 peak with motif6** \
```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif6: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_GAT_to_GATA3_pos_motif_6_compare_to_DHS.png") 
```
For GATA3 peaks with motif6, we have seen an enriched dyad structure of a GAT with 9bp relative distance to its opposite strand ATC. \
This is same as the RSAT defined atcn{6}atc|gatn{6}gat which rank as second highest ratio. And also match the motif2 PWMs/seqlogo. \


**GATA3 peak with motif5** \
```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif5: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_GAT_to_GATA3_pos_motif_5_compare_to_DHS.png") 
```
For GATA3 peaks with motif5, we did not see a very enriched dyad structure for GAT relative to +/- ATC. The relative distance at 5bp may or may not be enriched (afterall the ratio seems to be below 25). This is expected, because motif5 has a specific structure of ATCn{1}GAT, which ranked as 2nd highest ratio in the rsat results. This structure is different than GAT relative to +/- ATC. \




#### ATC-GAT

```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("ATC")
Query_dyad =c("GAT")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

**GATA3 peak with motif5** \
```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif6: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_GAT_to_closest_1st_ATC_to_GATA3_pos_motif_5_compare_to_DHS.png") 
```

As previous mentioned, now we see an enriched dyad structure of a ATC with 2bp relative distance to its opposite strand GAT, for peaks with motif5. \

This is same as the RSAT defined atcn{1}gat which rank as second highest ratio. And also match the motif5 PWMs/seqlogo. \

#### ATA-ATC
This structure is only enriched in GATA3 peaks with motif1 and motif2 according to RSAT results. \

```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("ATA")
Query_dyad =c("ATC")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif12456: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATA_to_GATA3_pos_motif_1_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATA_to_GATA3_pos_motif_2_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATA_to_GATA3_pos_motif_4_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATA_to_GATA3_pos_motif_5_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATA_to_GATA3_pos_motif_6_compare_to_DHS.png") 
```

It is clear in the enrichment graph that GATA3 peaks with motif1 has an enriched dyad structure of ATAn{2}ATC (relative distance of two zinc fingers is 8bp); GATA3 peaks with motif2 has an enriched dyad structure of ATAn{3}ATC (relative distance of two zinc finger is 9bp). \
For GATA3 peaks with motif4, ATAn{0}GAT and ATA{4}GAT are enriched. The relative distances of two zinc fingers are at 4bp and 8bp. \
No remarkable enrichment of dyad structure related to ATA and ATC for GATA3 peaks with motif5 and motif6. \


#### ATC-ATC
Notice that this is anchoring at ATC and looking for ATC on same strand or opposite strand. \
```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("ATC")
Query_dyad =c("ATC")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif12456: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATC_to_GATA3_pos_motif_1_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATC_to_GATA3_pos_motif_2_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATC_to_GATA3_pos_motif_4_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATC_to_GATA3_pos_motif_5_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATC_to_closest_1st_ATC_to_GATA3_pos_motif_6_compare_to_DHS.png") 
```
As expected, GATA3 peak with motif 1 and motif 2 do not show enrichment for dyad structure made of this pair of 3mer. \
GATA3 peak with motif4 has enrichment at relative distance 8bp for ATC and same strand ATC; \
GATA3 peak with motif6 has enrichment at relative distance 9bp for ATC and same strand ATC; \
GATA3 peak with motif5 has enrichment at relative distance 2bp for ATC and opposite strand ATC. \

These all match with the defined motif structure for each peak set. \


#### TAG-ATA
Unfortunately, **TAG** is not included in our prioritized list. It is ranked even after AGA/TCT. We can include an analysis of this 3-mer here. \
And in our customized analysis, we might also include TAG/CTA to our prioritized 3mer list. \

```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("TAG")
Query_dyad =c("ATA")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif12456: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_TAG_to_GATA3_pos_motif_1_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_TAG_to_GATA3_pos_motif_2_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_TAG_to_GATA3_pos_motif_4_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_TAG_to_GATA3_pos_motif_5_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_TAG_to_GATA3_pos_motif_6_compare_to_DHS.png") 
```
It is interesting to see that for all peak set, we did not have dyad structure of TAG{}TAT on the same strand. \
And for TAG-ATA on the same strand, we only see enrichment for GATA3 peaks with motif4 (rsat calculate the ratio is 68.72 ranked the third for tagn{0}ata). The relative distance between two zinc finger is 4. The binding element has to look like this: GATAGATA.  \

#### ATC-ATA
```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("ATC")
Query_dyad =c("ATA")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```


```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif12456: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_ATC_to_GATA3_pos_motif_1_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_ATC_to_GATA3_pos_motif_2_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_ATC_to_GATA3_pos_motif_4_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_ATC_to_GATA3_pos_motif_5_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_ATC_to_GATA3_pos_motif_6_compare_to_DHS.png") 
```
In these graph, we also did not see structure of ATC-TAT(opposite strand ATA). And only see one enriched structure for ATC-ATA at relative distance==2bp. This structure must be ATCxGATA, which match with motif5. \


#### GAT-ATA

```{r engine='R', eval=TRUE, echo=TRUE}
library(lattice)
library(latticeExtra)
library(Biostrings)
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
Anchor_dyad = c("GAT")
Query_dyad =c("ATA")
compute_dis_df=read.csv('pattern_anchor_at_G_compute_dis.csv')

for (motif in my_motifs) {
  print(motif)
  rsat_results=paste0("GATA3_peak_161win_with_", motif, "_RSAT_dyad.txt")
  for (pattern1 in Anchor_dyad){
    print(pattern1)
    for (pattern2 in Query_dyad){
      print(pattern2)
      number1=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==pattern2, "query"]
      rc_pattern2=reverseComplement(DNAString(pattern2))
      print(rc_pattern2)
      number2=compute_dis_df[compute_dis_df$pattern==pattern1, "anchor"] + compute_dis_df[compute_dis_df$pattern==as.character(rc_pattern2), "query"]
        
      ss <- process_and_subset_RSAT(rsat_results, pattern1, pattern2, number1)
      os <- process_and_subset_RSAT(rsat_results, pattern1, rc_pattern2, number2)
      
      if(nrow(ss) > 0) {
                        ss$query_status <- paste0("same_strand_", pattern2)
                        } else {
                        ss <- data.frame(matrix(NA, ncol = ncol(ss), nrow = 1)) # Fill ss dataframe with NA values for all columns
                        colnames(ss) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        ss$query_status <- paste0("same_strand_", pattern2)
                        }

      if(nrow(os) > 0) {
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        } else {
                        os <- data.frame(matrix(NA, ncol = ncol(os), nrow = 1)) # Fill os dataframe with NA values for all columns
                        colnames(os) <- c("first", "dyad_distance", "second", "ratio","relative_distance")
                        os$query_status <- paste0("opposite_strand_", pattern2)
                        }
      
      df.plot=rbind(ss, os)
      df.plot$query_status = factor(df.plot$query_status, levels = c(paste0("same_strand_", pattern2), paste0("opposite_strand_", pattern2)))
      
      # xy plot
      png(paste0('xy_RSAT_dyad_closest_2nd_', pattern2, '_to_closest_1st_', pattern1, '_to_GATA3_pos_', motif, '_compare_to_DHS.png'))
      print(xyplot(ratio ~ relative_distance,
                   data = df.plot, 
                   groups = query_status,
                   auto.key=list(space="right", points=TRUE),
                   aspect = 1,
                   xlim=c(-1,30),
                   ylim=c(0, 500),
                   xlab = paste0("distance (bp) from 2nd closest ",pattern2, " to closest ", pattern1),
                   ylab="RSAT obs/exp Ratio",
                    main=paste0("GATA3 peak with ", motif),
                   between=list(y=1.0),
                   scales = list(x = list(rot = 45, at = seq(from = 0, to = 50, by = 5))),
                   par.settings = list(superpose.symbol = list(col=c("orange", "darkgreen"), pch=18, lwd=2), strip.background=list(col="grey85")),
                   panel = function(x,y,...) {panel.abline(v=c(seq(1, 10, 1)), col = "grey90")
                                              panel.xyplot(x, y, 
                                                           col=c("orange","darkgreen"), 
                                                           pch=18, 
                                                           cex=0.6,...)
                                              #panel.barchart(x,y, horizontal = FALSE, col=c("red", "blue"), alpha=0.4)
                                      
                                      
                 }))
     dev.off()
    }  
  } 
}

```

```{r  fig.align = "center", out.width="80%", out.height="80%", echo=F, fig.align = "center", fig.cap="xy plot of rsat analysis for GATA3 peak with motif12456: 3mer structure"}
#library(knitr)
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_GAT_to_GATA3_pos_motif_1_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_GAT_to_GATA3_pos_motif_2_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_GAT_to_GATA3_pos_motif_4_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_GAT_to_GATA3_pos_motif_5_compare_to_DHS.png") 
knitr::include_graphics("./xy_RSAT_dyad_closest_2nd_ATA_to_closest_1st_GAT_to_GATA3_pos_motif_6_compare_to_DHS.png") 
```

Notice that we again did not see dyad structures of GAT-TAT(opposite stand ATA), but has identified enriched structure of GAT-ATA for GATA3 peaks with motif4 and motif6. \

For GATA3 peaks with motif4, we see gatn{6}ata and gatn{2}ata enriched. The relative distance between two zinc fingers is 8bp and 4bp. The 8bp one match with moyif4, the 4bp one match with GATAGATA. \
For GATA3 peaks with motif6, we see gatn{7}ata enriched, the relative distance between two zinc fingers is 9bp. This match with motif6 PWMs. \

**For the added 2 pairs of 3mer**: \

I have add the relative distance to the pattern_anchor_at_G_compute_dis.csv file. \
```{r engine='bash', eval=F, echo=TRUE}
pattern identifier anchor query
AGA	AGA(t)	2	1
TCT	(a)TCT	2	1
TAG	(ga)TAG	5	-2
CTA	CTA(tc)	-1	4
```



### Summary

Overall, RSAT-dyad analysis proves effective in identifying enriched binding elements within a set of peak regions, with proper controls and parameter settings. \

Enriched dyad structures can be discerned through various combinations of 3-mers. Establishing the relative distance between zinc fingers serves as a valuable method to determine if a structure arises from the same binding element. \



## Customized analysis -- prioritized 3mer

### Closest 3mer to peak summits

**Goal: given a prioritized 3mer list, we can generate the closest 3mer coordinates to a given sets of peak summits.** \

240208_closestBed.R: \

(cd /home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP_final/GAT_3mer_analaysis/closest_other_3mer) \
```{r engine='R', eval=F, echo=TRUE}
#!/usr/bin/env Rscript

Args=commandArgs(TRUE)
# closestBed function
bedTools.closest <- function(functionstring="/home/FCAM/ssun/packages/bedtools2/bin/closestBed",bed1,bed2,opt.string="") {
  
  options(scipen =99) # not use scientific notation when writing out
  
  #write bed formatted data.frames to tempfile
  write.table(bed1,file= 'a.file.bed', quote=F,sep="\t",col.names=F,row.names=F)
  write.table(bed2,file= 'b.file.bed', quote=F,sep="\t",col.names=F,row.names=F)
  
  # create the command string and call the command using system()
  # the command sort a and b file by coordinates
  command1=paste('sort -k1,1 -k2,2n', 'a.file.bed', '> a.file.sorted.bed')
  cat(command1,"\n") #sort -k1,1 -k2,2n a.file.bed > a.file.sorted.bed
  try(system(command1))
  command2=paste('sort -k1,1 -k2,2n', 'b.file.bed', '> b.file.sorted.bed')
  cat(command2,"\n")
  try(system(command2))
  
  # the command call closestBed on bed1 and bed2
  command=paste(functionstring, opt.string,"-a",'a.file.sorted.bed',"-b",'b.file.sorted.bed',">",'out.file.bed',sep=" ")
  cat(command,"\n")
  try(system(command))
  
  res=read.table('out.file.bed',header=F, comment.char='')
  
  # remove intermediate files
  command3=paste('rm', 'a.file.bed', 'b.file.bed', 'a.file.sorted.bed', 'b.file.sorted.bed', 'out.file.bed')
  cat(command3,"\n")
  try(system(command3))
  
  colnames(res) = c(colnames(bed1), colnames(bed2), 'dis' )
  return(res)
}

dir1="/labs/Guertin/siyu/Sathyan_GATA3_ChIP_pool1_pool2/overrep_3mer/hg38_full_kmer3_rs1000/seqdump/"
dir2="/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP_final/GAT_3mer_analaysis/MAST_positive_control/"
dir3="/home/FCAM/ssun/GATA3_ChIP_PRO_July2023/ChIP_final/GAT_3mer_analaysis/ENCODE_DHS_GSE29692/"
my_motifs = c("motif_1", "motif_4","motif_2", "motif_6", "motif_5")
prioritized_triplets = c("AAA", "TAA" ,"ATA" ,"TTA", "AAT", "TAT", "GAT", "ATT", "TTT", "ATC", "AGA", "TCT", "TAG", "CTA")
library(bigWig)

for (triplet in prioritized_triplets){
  print(triplet)
  # 3mer genome coordinates
  plus.triplet.file=read.table(file = Sys.glob(file.path(paste0(dir1,"hg38.3.3.3plus.*_",triplet, ".bed"))), sep="\t", header=FALSE)
  minus.triplet.file=read.table(file = Sys.glob(file.path(paste0(dir1,"hg38.3.3.3minus.*_",triplet ,".bed"))), sep="\t", header=FALSE)
  for (motif in my_motifs){
    print(motif)
    # peak summits
    GATA3_peak_summits=center.bed(read.table(paste0(dir2, "GATA3_peak_161win_with_",motif, ".bed"), header=FALSE), upstreamWindow = 0, downstreamWindow = 0)
    # consensus neg
    indep.DHS.control.consensus=center.bed(read.table(paste0(dir3, "MCF7DHS_consensus_noGATA_without_motifs_123456_78.bed"), header=FALSE), upstreamWindow = 0, downstreamWindow = 0)
    
    # closestBed--1st closest plus
    
    ##
    closest.1st.plus.triplet.to.peak=bedTools.closest(bed1 = GATA3_peak_summits[,1:3], bed2 = plus.triplet.file, opt.string = '-d -t first')
    write.table(closest.1st.plus.triplet.to.peak,file= paste0('closest.1st.plus.',triplet,'.to.GATA3.with.', motif,'.bed'), quote=F,sep="\t",col.names=F,row.names=F)
    
    ##
    closest.1st.plus.triplet.to.indep.DHS.control.consensus=bedTools.closest(bed1 = indep.DHS.control.consensus[,1:3], bed2 = plus.triplet.file, opt.string = '-d -t first')
    write.table(closest.1st.plus.triplet.to.indep.DHS.control.consensus,file= paste0('closest.1st.plus.',triplet,'.to.indep.DHS.control.consensus.bed'), quote=F,sep="\t",col.names=F,row.names=F)


     # closestBed--1st closest minus
     
     ##
     closest.1st.minus.triplet.to.peak=bedTools.closest(bed1 = GATA3_peak_summits[,1:3], bed2 =minus.triplet.file, opt.string = '-d -t first')
     write.table(closest.1st.minus.triplet.to.peak,file= paste0('closest.1st.minus.',triplet,'.to.GATA3.with.', motif,'.bed'), quote=F,sep="\t",col.names=F,row.names=F)
     
     ##
     closest.1st.minus.triplet.to.indep.DHS.control.consensus=bedTools.closest(bed1 = indep.DHS.control.consensus[,1:3], bed2 = minus.triplet.file, opt.string = '-d -t first')
    write.table(closest.1st.minus.triplet.to.indep.DHS.control.consensus,file= paste0('closest.1st.minus.',triplet,'.to.indep.DHS.control.consensus.bed'), quote=F,sep="\t",col.names=F,row.names=F)

  }
  
}
```

runR.sh \
```{r engine='bash', eval=F, echo=TRUE}
#!/bin/bash
#SBATCH --job-name=runR.sh     # name for job
#SBATCH -N 1
#SBATCH -n 1
#SBATCH -c 8
#SBATCH -p general
#SBATCH --qos=general
#SBATCH --mem=200G
#SBATCH --mail-type=ALL
#SBATCH --mail-user=ssun@uchc.edu
#SBATCH -o runR.sh_%j.out
#SBATCH -e runR.sh_%j.err

module load R/4.1.2
Rscript 240208_closestBed.R
```


### 2nd closest 3mer to the anchor 3mer
**Goal: given the closest 3mer coordinates file, we can loop through a set of 3mer list and generate the 2nd closest 3mer coordinates to the provided closest 3mer coordinates.** \


